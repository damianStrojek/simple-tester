1. W przypadku klas w Javie (1 poprawna):
4
Nie istnieje mo¿liwoœæ implementowania wielu interfejsów
Nie istnieje mo¿liwoœæ dziedziczenia po wielu klasach bazowych
Wszystkie metody klasy bazowej musz¹ byæ nadpisane w klasie potomnej
¯adne z powy¿szych
b

2. W przypadku kolekcji TreeSet (1 poprawna):
4
Wyszukiwanie elementów cechuje siê z³o¿onoœci¹ liniow¹ O(n)
Wyszukiwanie elementów cechuje siê z³o¿onoœci¹ logarytmiczn¹ O(log n)
Wyszukiwanie elementów odbywa siê w czasie sta³ym O(1)
Dane maj¹ postaæ par (klucz -> wartoœæ)
b

3. Narzêdzie Maven (2 poprawne):
4
Jest czêœci¹ œrodowiska Netbeans i nie mo¿e byæ wykorzystywane poza nim
Automatycznie zarz¹dza zale¿noœciami projektu
Wymaga od u¿ytkownika dostarczenia wszystkich plików JAR stanowi¹cych zale¿noœci projektu
U³atwia przenoszenie projektu pomiêdzy ró¿nymi komputerami i œrodowiskami programistycznymi
b d

4. Do strumieni znakowych (character streams) w bibliotece wejœcia/wyjœcia Javy nale¿¹ (2 poprawne):
4
InputStream
FileWriter
BufferedReader
BufferedInputStream
b c

5. W aplikacji internetowej opartej na frameworku Spring MVC (2 poprawne):
4
Transakcje nie s¹ obs³ugiwane przez framework
Adnotacja @Transactional umo¿liwia wykorzystanie transakcji
Transakcja zostanie wycofana (rollback) w przypadku wyst¹pienia dowolnego wyj¹tku
Transakcja zostanie wycofana (rollback) w przypadku wyst¹pienia wyj¹tku z hierarchii RuntimeException
b d

6. Wyra¿enie lambda () -> { System.out.println("PT); } mo¿na przypisaæ do zmiennej typu (1 poprawna):
4
Comparable
Runnable
Comparator
String
b

7. Testy jednostkowe (2 poprawne):
4
Gwarantuj¹ poprawnoœæ dzia³ania ca³ej aplikacji
Badaj¹ ka¿dy komponent w izolacji od jego zale¿noœci
Mog¹ byæ u¿ywane tylko dla komponentów, które nie posiadaj¹ zale¿noœci
Wykorzystuj¹ obiekty-zaœlepki (mock) w miejscu zale¿noœci testowanych komponentów
b d

8. W przypadku kolekcji implementuj¹cej interfejs Set (2 poprawne):
5
Kolejnoœæ elementów w kolekcji jest zawsze zgodna z kolejnoœci¹ ich dodawania
Elementy s¹ zawsze posortowane w kolekcji
W kolekcji mog¹ wystêpowaæ powtarzaj¹ce siê elementy
Na pewno nie a, b i c
W kolekcji nie mog¹ wystêpowaæ powtarzaj¹ce siê elementy. Interfejs set nie zawiera duplikatów.
d e

9. Zaznacz mo¿liwoœci, udostêpniane przez biblioteki implementuj¹ce specyfikacjê JPA (2 poprawne):
4
Generowanie schematu bazy danych na podstawie klas encyjnych opatrzonych adnotacjami
Serializacja obiektów encyjnych do formatu JSON lub XML
Generowanie dokumentu XML na podstawie schematu bazy danych
Generowanie klas encyjnych na podstawie schematu bazy danych
a d

10. Interfejsy funkcyjne (functional interfaces) w jêzyku Java (1 poprawna):
4
Mog¹ posiadaæ dowoln¹ liczbê metod wymagaj¹cych zaimplementowania
Musz¹ posiadaæ dok³adnie jedn¹ metodê wymagaj¹c¹ zaimplementowania
Musz¹ posiadaæ implementacje domyœlne dla wszystkich metod
Nie wystêpuj¹ - jest to element jêzyka C#
b

11. W przypadku dziedziczenia (1 poprawna):
4
Istnieje mo¿liwoœæ implementowania wielu interfejsów
Istnieje mo¿liwoœæ dziedziczenia po wielu klasach bazowych
S³owo kluczowe master odwo³uje siê do klasy bazowej
S³owo kluczowe base odwo³uje siê do klasy bazowej
a

12. W przypadku kolekcji implementuj¹cych interfejs List (1 poprawna):
4
Kolejnoœæ elementów w kolekcji jest zgodna z kolejnoœci¹ ich dodawania
Elementy s¹ zawsze posortowane w kolekcji
W kolekcji nie mog¹ wystêpowaæ powtarzaj¹ce siê elementy
Dane maj¹ postaæ par klucz -> wartoœæ
a

13. JAXB pozwala na (2 poprawne):
4
Odczytywanie dokumentów XML
Zapisywanie dokumentów XML
Generowanie klas w jêzyku Java na podstawie pliku XML
Generowanie dokumentu .xsd na podstawie pliku XML
a b

14. Zaznacz poprawne konwencje kodowania dla jêzyka Java (2 poprawne):
4
Nazwy metod i zmiennych zaczynamy duz¹ liter¹; ka¿de kolejne s³owo, sk³adaj¹ce siê na nazwê, równie¿ zaczynamy du¿¹ liter¹, np. int NazwaZmiennej
Nazwy zmiennych zaczynamy ma³¹ liter¹; ka¿de kolejne s³owo, sk³adaj¹ce siê na nazwê, zaczynamy du¿¹ liter¹, np. int nazwaZmiennej
Nazwy metody piszemy wy³¹cznie ma³ymi literami, ka¿de kolejne s³owo oddzielamy podkreœleniem, np. nazwa_metody()
Nazwy sta³ych piszemy wy³¹cznie wielkimi literami, kolejne s³owa oddzielamy podkreœleniem, np. NAZWA_STA£EJ
b d

15. Poprawne definicje w¹tków wystêpuj¹cych w aplikacjach opartych o JavaFX to (1 poprawna):
4
Event Dispatch Thread - pozwala na modyfikacjê interfejsu u¿ytkownika
Media thread - renderowanie interfejsu poza obs³ug¹ zdarzeñ, pozwala na renderowanie kolejnej ramki, gdy poprzednia jest synchronizowana
JavaFX application thread - g³ówny w¹tek aplikacji, wszystkie dostêpy do wyœwietlanej sceny musz¹ byæ zrealizowane w tym w¹tku
Prism renderer thread - dzia³a w tle, synchronizuje ramki za pomoc¹ grafu sceny, wykorzystuj¹c JavaFX application thread
c

16. Zaznacz poprawne sformu³owana na temat API Stream, wprowadzonego w wersji SE8 jêzyka Java (2 poprawne):
4
Wyró¿niamy strumienie sekwencyjne i równoleg³e
Strumieñ mo¿na pozyskaæ z dowolnej kolekcji implementuj¹cej interfejs Collection
W przypadku strumieni wspó³bie¿nych nie jest mo¿liwe okreœlenie liczby w¹tków, które bêd¹ przetwarzaæ elementy strumienia
Przydatnoœæ API Stream jest ograniczona przez brak integracji z wyró¿nieniami lambda
a b

17. Zaznacz poprawne sformu³owania na temat Java Persistence API (2 poprawne):
4
Instancja klasy EntityManager nie powinna byæ wykorzystywana przez wiêcej ni¿ jeden w¹tek
Instancja klasy EntityManagerFactory nie powinna byæ wykorzystywane przez wiêcej ni¿ jeden w¹tek
Instancja klasy EntityManagerFactory mo¿e byæ bezpiecznie wykorzystywana przez wiele w¹tków równoczeœnie
Instancja klasy EntityManager mo¿e byæ bezpiecznie wykorzystywane przez wiele w¹tków równoczeœnie
a c

18. Zaznacz poprawne sformu³owania na temat wyra¿eñ lambda w jêzyku Java (1 poprawna):
4
Wyró¿niamy wyra¿enia sekwencyjne i równoleg³e
Wyra¿enia lambda s¹ zupe³nie nowym mechanizmem w Javie SE8 i nie mo¿na zintegrowaæ ich z kodem istniej¹cym przed wydaniem tej wersji jêzyka
Wyra¿enia lambda mo¿na ³atwo wprowadziæ do istniej¹cego ju¿ kodu, o ile aplikacja bêdzie uruchamiana na maszynie wirtualnej w wersji SE8
W obrêbie wyra¿enia lambda mo¿na odwo³ywaæ siê do wszystkich zmiennych zdefiniowanych poza wyra¿eniem
c

19. Jakiego typu s¹ wyra¿enia lambda, skoro Java nale¿y do silnie typowanych jêzyków? (1 poprawna)
4
Wszystkie wyra¿enia s¹ tego samego typu, który reprezentuje wbudowana klasa Lambda
Ka¿de wyra¿enie lambda definiuje niejawnie w³asny typ, który jest znany tylko w czasie wykonania programu
Wyra¿enie jest typu interfejsu funkcyjnego, który implementuje
Wyra¿enia lambda nie s¹ obiektami, wiêc nie posiadaj¹ typu
c

20. Typy kolekcji s¹ reprezentowane przez nastêpuj¹ce interfejsy (2 poprawne):
4
SortedMap
ISet
SortedSet
LinkedList
a c

21. W³aœciwoœci wi¹zane, to takie które (1 poprawna):
4 
posiadaj¹ adnotacjê @Bounded
nie nale¿y modyfikowaæ z poziomu kodu Ÿród³owego, mog¹ byæ modyfikowane jedynie z poziomu interfejsu u¿ytkownika
s¹ powi¹zane wy³¹cznie z jednym elementem interfejsu u¿ytkownika
wspieraj¹ informowanie o zmianach swego stanu
d

22. Modyfikacjê interfejsu u¿ytkownika w bibliotece Swing nale¿y wykonywaæ w (2 poprawne):
4
g³ównym w¹tku aplikacji
event dispatch thread
w¹tku obs³ugi zdarzeñ
worker thread
b c

23. Aby skorzystaæ z gniazdek po³¹czeniowych (2 poprawne):
4
serwer musi nas³uchiwaæ przy pomocy klasy ServerSocket
Java obs³uguje jedynie gniazda bezpo³¹czeniowe
klient mo¿e wysy³aæ za pomoc¹ klas Socket i MulticastSocket
serwer musi nas³uchiwaæ przy pomocy klasy DatagramSocket
a c

24. Które zdania s¹ prawdziwe w odniesieniu do obs³ugi gniazdek sieciowych (2 poprawne)?
4
Obiekt Socket reprezentuje tylko stronê serwerow¹ po³¹czenia
Obiekt Socket reprezentuje dowoln¹ stronê po³¹czenia
Obiekt Socket reprezentuje tylko stronê klienck¹ po³¹czenia
Obiekt ServerSocket pozwala na akceptowanie przychodz¹cych po³¹czeñ
b d

25. Aby zaimplementowaæ nowy w¹tek (3 poprawne):
4
w ka¿dym przypadku zalecane jest dziedziczenie po klasie Thread
mo¿na dziedziczyæ po klasie Thread
mo¿na implementowaæ interfejs Runnable
zalecana jest implementacja interfejsu Runnabe
b c d

26. Poprawne stwierdzenie dotycz¹ce Java Beans to (2 poprawne):
4
mog¹ zawieraæ publiczne pola nie bêd¹ce sta³ymi
komponenty Java Bean musz¹ byæ serializowalne
zawieraj¹ domyœlny konstruktor bez parametrów (musi go posiadaæ)
nie mog¹ zawieraæ konstruktorów sparametryzowanych
b c

27. Które z poni¿szych klas definiuj¹ podstawowe rodzaje (nie konkretne implementacje) kolekcji (2 poprawne)?
4
ArrayList
HashSet
Set
List
c d

28. Które zdania s¹ poprawne w odniesieniu do platformy Java (2 poprawne)?
4
Nieu¿ywane (nie posiadaj¹ce referencji) obiekty s¹ usuwane automatycznie
Kod bajtowy kompilowany jest do kodu natywnego w czasie budowania
Programista musi zadbaæ o usuwanie nieu¿ywanych (nie posiadaj¹cych referencji) obiektów
Kod bajtowy kompilowany jest do kodu natywnego w czasie wykonania
a d

29. Które zdania s¹ poprawne w odniesieniu do spójnoœci metod Object#equals i Object#hashCode (2 poprawne)?
4
Jeœli metoda equals zwraca false to wartoœci hashCode powinny (nie musz¹) byæ ró¿ne
Jeœli metoda equals zwraca true to wartoœci hashCode musz¹ byæ takie same
Jeœli metoda equals zwraca false to wartoœci hashCode musz¹ byæ ró¿ne
Jeœli metoda equals zwraca true to wartoœci hashCode powinny (nie musz¹) byæ takie same
a b

30. Które zdania s¹ prawdziwe w odniesieniu do tworzenia nowego w¹tku (2 poprawne)?
4
Zaleca siê implementacja interfejsu Runnable w celu implementacji zadania do wykonania
Zaleca siê wykorzystanie obiektu Thread do uruchomienia nowego w¹tku
Zaleca siê wykorzystanie obiektu Runnable do uruchomienia nowego w¹tku
Zaleca siê dziedziczenie po klasie Thread w celu implementacji zadania do wykonania
a b

31. Które zdanie opisuje wykonanie wspó³bie¿ne procesów (1 poprawna)?
4
Akcje s¹ wykonywane w tym samym czasie na kilku procesorach (lub rdzeniach)
Procesy nie mog¹ byæ wykonywane wspó³bie¿nie
Poszczególne akcje procesu s¹ wykonywane jedna po drugiej, kolejna akcja rozpoczyna siê po zakoñczeniu poprzedniej
Kolejna akcja mo¿e rozpocz¹æ siê przed zakoñczeniem poprzedniej, akcje mog¹ byæ wykonywane w tym samym czasie lub z przeplotem (procesor prze³¹cza siê pomiêdzy ró¿nymi akcjami)
d

32. Które zdania s¹ poprawne w odniesieniu do przygotowania g³ównej metody (wejœcie programu)? (2 poprawne)
4
Typy argumentów g³ównej metody s¹ narzucone z góry
Nazwa g³ównej klasy jest narzucona z góry
Nazwy argumentów g³ównej metody s¹ narzucone z góry
Nazwa g³ównej metody jest narzucona z góry
a d

33. Które zdania s¹ prawdziwe w odniesieniu do obs³ugi sekcji krytycznej (2 poprawne)?
4
Metoda Object#wait nie blokuje sekcji krytycznej
Metoda Thread.sleep blokuje sekcjê krytyczn¹
Metoda Thread.sleep nie blokuje sekcji krytycznej
Metoda Object#wait blokuje sekcjê krytyczn¹
a b

34. Które z wymienionych implementacji strumieniu definiuj¹ Ÿród³o/cel danych, a nie sposób odczytu/zapisu danych (2 poprawne)?
4
FileInputStream , FileOutputStream
SocketInputStream , SocketOutputStream
ObjectInputStream , ObjectOutputStream
BufferedInputStream , BufferedOutputStream
a b

35. W jakich stanach obiekt encyjny jest zwi¹zany kontekstem trwa³oœci (persistence)? (2 poprawne)
4
removed
detached
managed
new
a c

36. Do standardowych strumieni znakowych nale¿¹ (2 poprawne):
4
PrintWriter
MemoryWriter
InputStream
BufferedReader
a d

37. Poprawne stwierdzenia dotycz¹ce kolekcji to (1 poprawna):
4
Aby zapewniæ automatyczne sortowanie elementów kolekcji, musz¹ one implementowaæ interfejs Comparable
Elementy kolekcji mo¿na usuwaæ podczas przegl¹dania za pomoc¹ pêtli foreach
Podczas przegl¹dania kolekcji iteratorem mo¿na go wykorzystaæ do usuwania elementów
Aby zapewniæ automatyczne sortowanie elementów kolekcji, musz¹ one implementowaæ interfejs Comparator
c